---
layout: post
title:  "直接插入排序"
date:   2019-02-23 11:43:00 +0800
categories: 技术
tag: 教程
---

* content
{:toc}

### 算法介绍

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

### 算法描述

1. 从第一个元素开始，该元素可以认为已经被排序；
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
5. 将新元素插入到该位置后；
6. 重复步骤2~5。

### 算法解释

其实就跟我们打牌的时候,理牌的原理是一样的.
1. 我们最先开始抓到了一手没整理过的牌
2. 然后认为第一张是已经整理过,最小的牌.
3. 取出第二张牌,跟第一张牌对比,小的放左,大的放右.
4. 以此类推.

### 算法动图演示

![直接插入排序动图演示](/styles/images/pages/2019-02-23-01.gif)

### 算法代码C语言实现

```c
// 直接插入排序
void insort(int s[], int n){
    int i,j;
    // 从下标2开始，s[0]做监视哨，s[1]一个数据无可比性
    for(i = 2; i <= n; i ++){
        // 给监视哨赋值
        s[0] = s[i];
        // 确定要比较元素的最右边位置
        j = i - 1;
        while(s[0] < s[j]){
            // 数据右移
            s[j + 1] = s[j];
            // 移向左边一个未比较的数
            j --;
        }
        // 在确定的位置插入s[i]
        s[j + 1] = s[0];
    }
}
```

### 时间复杂度分析

若设待排序的元素个数为n，则该算法会执行n-1趟。

因为排序码比较次数和元素移动次数与元素排序码的初始排列有关，所以在最好的情况下，即在排序前元素已经按排序码大小从小到大排好了，每趟只需与前面的有序元素序列的最后一个元素的排列吗进行比较，总的排序码比较次数为n-1，元素移动次数为0。

而在最差的情况下，及第i趟时第i个元素必须与前面i个元素都做排序码的比较，并且每做一次就叫就要做一次数据移动，则在最坏的情况下排序码的排序码比较次数KCN和元素移动次数RMN分别为:

![直接排序时间复杂度](/styles/images/pages/2019-02-23-02.png)

从上面的讨论可以看出来，直接插入排序的运行时间和待排序元素的原始排序顺序密切相关。

如果待排序元素序列中出现各种可能排列的概率相同，则可以取上述最好和最坏情况的平均情况，在平均情况下的排序码比较次数和元素移动次数约为n^2/4。

因此，**直接插入排序的时间复杂度为O(n^2)。并且直接插入排序是一种稳定的排序方法**。

### 性能分析

- 时间复杂度： 
    - 顺序排列时，只需比较(n-1)次，插入排序时间复杂度为O(n)；
    -  逆序排序时，需比较n(n-1)/2次，插入排序时间复杂度为O(n^2)； 
    -  当原始序列杂乱无序时，平均时间复杂度为O(n^2)。

- 空间复杂度： 
    - 插入排序过程中，需要一个临时变量temp存储待排序元素，因此空间复杂度为O(1)。

- 算法稳定性： 
    - 插入排序是一种稳定的排序算法。

### 使用场景

数据量小时使用。并且大部分已经被排序。