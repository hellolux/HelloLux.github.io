---
layout: post
title:  "希尔排序"
date:   2019-02-25 10:05:00 +0800
categories: 技术
tag: 教程
---

* content
{:toc}

### 算法介绍

1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

### 算法描述

1. 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序
2. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
3. 按增量序列个数k，对序列进行k 趟排序；
4. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。
5. 仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 算法动图演示

![希尔排序动图演示](/styles/images/pages/2019-02-25-01.gif)

### 算法代码C语言实现

```c
// 希尔排序
void shsort(int s[], int n){
    int i,j,d,temp;
    // 固定增量值
    d = n / 2;
    while(d >= 1){
        // 数组下标从d+1开始进行直接插入排序
        for(i = d + 1; i <= n; i ++){
            // 设置监视哨
            s[0] = s[i];
            // 确定要比较的元素最右的位置
            j = i - d;
            while( (j > 0) && (s[0] < s[j])){
                // 数据右移
                s[j + d] = s[j];
                // 左移d个位置
                j = j - d;
            }
            temp = s[j + d];
            // 在确定的位置插入s[i]
            s[j + d] = s[0];
        }
        // 增量变为原来的一半
        d = d / 2;
    }
}
```

### 时间复杂度分析

希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。

对希尔排序的时间复杂度分析很困难，在特定情况下可以准确的估算排序码的比较次数和元素移动的次数，但要想弄清楚排序码比较次数和元素移动次数与增量选择之间的依赖关系，并给出完整的数学分析，还没有人能够做到。 

### 使用场景

希尔排序是基于插入排序的一种算法， 在此算法基础之上增加了一个新的特性，提高了效率。

希尔排序的时间复杂度与增量序列的选取有关

希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择

希尔排序非常容易实现，算法代码短而简单

几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法
